#include "framework.h"
#include "Mesh.h"

CDiffusedVertex::CDiffusedVertex()
{
	m_xmf3Position		 = XMFLOAT3(0.0f, 0.0f, 0.0f);
	m_xmf4Diffuse		 = XMFLOAT4(0.0f, 0.0f, 0.0f, 0.0f);
}

CDiffusedVertex::CDiffusedVertex(FLOAT x, FLOAT y, FLOAT z, XMFLOAT4 xmf4Diffuse)
{
	m_xmf3Position		 = XMFLOAT3(x, y, z);
	m_xmf4Diffuse		 = xmf4Diffuse;
}

CDiffusedVertex::CDiffusedVertex(XMFLOAT3 xmf3Position, XMFLOAT4 xmf4Diffuse)
{
	m_xmf3Position		 = xmf3Position;
	m_xmf4Diffuse		 = xmf4Diffuse;
}

//========================================================================================================================================

CMesh::CMesh(ID3D12Device* pd3dDevice, ID3D12GraphicsCommandList* pd3dCommandList)
{
}

CMesh::~CMesh()
{
	if (m_pd3dVertexBuffer)
		m_pd3dVertexBuffer->Release();

	if (m_pd3dVertexUploadBuffer)
		m_pd3dVertexUploadBuffer->Release();

	if (m_pd3dIndexBuffer)
		m_pd3dIndexBuffer->Release();

	if (m_pd3dIndexUploadBuffer)
		m_pd3dIndexUploadBuffer->Release();
}

void CMesh::Release()
{
	if (--m_nReferences <= 0)
		delete this;
}

void CMesh::ReleaseUploadBuffers()
{
	// Vertex 버퍼를 위한 업로드 버퍼 소멸
	if (m_pd3dVertexUploadBuffer)
		m_pd3dVertexUploadBuffer->Release();

	if (m_pd3dIndexUploadBuffer)
		m_pd3dIndexUploadBuffer->Release();

	m_pd3dVertexUploadBuffer	 = nullptr;
	m_pd3dIndexUploadBuffer		 = nullptr;
}

void CMesh::Render(ID3D12GraphicsCommandList* pd3dCommandList)
{
	pd3dCommandList->IASetPrimitiveTopology(m_d3dPrimitiveTopology);			// Mesh의 Primitive 유형을 설정
	pd3dCommandList->IASetVertexBuffers(m_nSlot, 1, &m_d3dVertexBufferView);	// Mesh의 Vertex 버퍼 뷰를 설정

	if (m_pd3dIndexBuffer)
	{
		// Index 버퍼가 있으면 Index 버퍼를 Pipeline(IA: 입력 조립기)에 연결하고 Index를 사용하여 Rendering
		pd3dCommandList->IASetIndexBuffer(&m_d3dIndexBufferView);
		pd3dCommandList->DrawIndexedInstanced(m_nIndices, 1, 0, 0, 0);
	}
	else
		pd3dCommandList->DrawInstanced(m_nVertices, 1, m_nOffset, 0);			// Mesh의 Vertex 버퍼 뷰를 Rendering(Pipeline(입력 조립기)을 작동하게 한다)
}

//========================================================================================================================================

CHeightMapImage::CHeightMapImage(LPCTSTR pFileName, INT nWidth, INT nLength, XMFLOAT3 xmf3Scale)
{
	m_nWidth		 = nWidth;
	m_nLength		 = nLength;
	m_xmf3Scale		 = xmf3Scale;

	BYTE* pHeightMapPixels{ new BYTE[m_nWidth * m_nLength] };

	// 파일을 열고 읽는다. Height Map 이미지는 파일 Header가 없는 RAW 이미지이다.
	HANDLE	 hFile{ ::CreateFile(pFileName, GENERIC_READ, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_READONLY, nullptr) };
	DWORD	 dwBytesRead;

	::ReadFile(hFile, pHeightMapPixels, (m_nWidth * m_nLength), &dwBytesRead, nullptr);
	::CloseHandle(hFile);

	/*이미지의 y축과 지형의 z축이 방향이 반대이므로 이미지를 상하대칭 시켜 저장.
	그러면 이미지의 좌표축과 지형의 좌표축의 방향이 일치하게 된다.*/
	m_pHeightMapPixels = new BYTE[m_nWidth * m_nLength];

	for (INT y = 0; y < m_nLength; ++y)
	{
		for (INT x = 0; x < m_nWidth; ++x)
		{
			m_pHeightMapPixels[x + ((m_nLength - 1 - y) * m_nWidth)] = pHeightMapPixels[x + (y * m_nWidth)];
		}
	}

	if (pHeightMapPixels)
		delete[] pHeightMapPixels;
}

CHeightMapImage::~CHeightMapImage()
{
	if (m_pHeightMapPixels)
		delete[] m_pHeightMapPixels;
	
	m_pHeightMapPixels = nullptr;
}

FLOAT CHeightMapImage::GetHeight(FLOAT fx, FLOAT fz)
{
	// 지형의 좌표 (fx, fz)는 이미지 좌표계이다. Height Map의 x좌표와 z좌표가 Height Map의 범위를 벗어나면 지형의 높이는 0이다.
	if ((fx < 0.0f) || (fz < 0.0f) || (fx >= m_nWidth) || (fz >= m_nLength))
		return 0.0f;

	// Height Map의 좌표의 정수 부분과 소수 부분을 계산
	INT		 x{ (INT)fx};
	INT		 z{ (INT)fz};
	FLOAT	 fxPercent{ fx - x };
	FLOAT	 fzPercent{ fz - z };
	FLOAT	 fBottomLeft{ (FLOAT)m_pHeightMapPixels[x + (z * m_nWidth)] };
	FLOAT	 fBottomRight{ (FLOAT)m_pHeightMapPixels[(x + 1) + (z * m_nWidth)] };
	FLOAT	 fTopLeft{ (FLOAT)m_pHeightMapPixels[x + ((z + 1) * m_nWidth)] };
	FLOAT	 fTopRight{ (FLOAT)m_pHeightMapPixels[(x + 1) + ((z + 1) * m_nWidth)] };

#ifdef _WITH_APPROXIMATE_OPPOSITE_CORNER
	// z좌표가 1, 3, 5, ...인 경우 Index가 오른쪽에서 왼쪽으로 나열된다.
	bool bRightToLeft = ((z % 2) != 0);
	if (bRightToLeft)
	{
		/*지형의 삼각형들이 오른쪽에서 왼쪽 방향으로 나열되는 경우이다.
		다음 그림의 오른쪽은 (fzPercent < fxPercent) 인 경우이다.
		이 경우 TopLeft의 Pixel 값은 (fTopLeft = fTopRight + (fBottomLeft - fBottomRight))로 근사한다.
		다음 그림의 왼쪽은 (fzPercent ≥ fxPercent)인 경우이다.
		이 경우 BottomRight의 Pixel 값은 (fBottomRight = fBottomLeft + (fTopRight - fTopLeft))로 근사한다.*/
		if (fzPercent >= fxPercent)
			fBottomRight = fBottomLeft + (fTopRight - fTopLeft);
		else
			fTopLeft = fTopRight + (fBottomLeft - fBottomRight);
	}
	else
	{
		/*지형의 삼각형들이 왼쪽에서 오른쪽 방향으로 나열되는 경우이다.
		다음 그림의 왼쪽은 (fzPercent < (1.0f - fxPercent))인 경우이다.
		이 경우 TopRight의 Pixel 값은 (fTopRight = fTopLeft + (fBottomRight - fBottomLeft))로 근사한다.
		다음 그림의 오른쪽은 (fzPercent ≥ (1.0f - fxPercent))인 경우이다.
		이 경우 BottomLeft의 Pixel 값은 (fBottomLeft = fTopLeft + (fBottomRight - fTopRight))로 근사한다.*/
		if (fzPercent < (1.0f - fxPercent))
			fTopRight = fTopLeft + (fBottomRight - fBottomLeft);
		else
			fBottomLeft = fTopLeft + (fBottomRight - fTopRight);
	}
#endif

	// 사각형의 네 점을 보간하여 높이(Pixel 값) 계산
	FLOAT fTopHeight{ fTopLeft * (1 - fxPercent) + fTopRight * fxPercent };
	FLOAT fBottomHeight{ fBottomLeft * (1 - fxPercent) + fBottomRight * fxPercent };
	FLOAT fHeight{ fBottomHeight * (1 - fzPercent) + fTopHeight * fzPercent };

	return fHeight;
}

XMFLOAT3 CHeightMapImage::GetHeightMapNormal(INT x, INT z)
{
	// x좌표와 z좌표가 Height Map의 범위를 벗어나면 지형의 법선 벡터는 y축 방향 벡터
	if ((x < 0.0f) || (z < 0.0f) || (x >= m_nWidth) || (z >= m_nLength))
		return XMFLOAT3(0.0f, 1.0f, 0.0f);

	// Height Map에서 (x, z) 좌표의 Pixel 값과 인접한 두 개의 점 (x + 1, z), (z, z + 1)에 대한 Pixel 값을 사용하여 법선 벡터 계산
	INT			 nHeightMapIndex{ x + (z * m_nWidth) };
	INT			 xHeightMapAdd{ (x < (m_nWidth - 1)) ? 1 : -1 };
	INT			 zHeightMapAdd{ (z < (m_nLength - 1)) ? m_nWidth : -m_nWidth };

	// (x, z), (x + 1, z), (z, z + 1)의 Pixel에서 지형의 높이 계산
	FLOAT		 y1{ (FLOAT)m_pHeightMapPixels[nHeightMapIndex] * m_xmf3Scale.y };
	FLOAT		 y2{ (FLOAT)m_pHeightMapPixels[nHeightMapIndex + xHeightMapAdd] * m_xmf3Scale.y };
	FLOAT		 y3{ (FLOAT)m_pHeightMapPixels[nHeightMapIndex + zHeightMapAdd] * m_xmf3Scale.y };

	// xmf3Edge1은 (0, y3, m_xmf3Scale.z) - (0, y1, 0) 벡터이다.
	XMFLOAT3	 xmf3Edge1{ XMFLOAT3(0.0f, y3 - y1, m_xmf3Scale.z) };

	// xmf3Edge2는 (m_xmf3Scale.x, y2, 0) - (0, y1, 0) 벡터이다.
	XMFLOAT3	 xmf3Edge2{ XMFLOAT3(m_xmf3Scale.x, y2 - y1, 0.0f) };

	// 법선 벡터는 xmf3Edge1과 xmf3Edge2의 외적을 정규화하면 된다.
	XMFLOAT3	 xmf3Normal{ Vector3::CrossProduct(xmf3Edge1, xmf3Edge2, TRUE) };

	return xmf3Normal;
}

//========================================================================================================================================

CTriangleMesh::CTriangleMesh(ID3D12Device* pd3dDevice, ID3D12GraphicsCommandList* pd3dCommandList) : CMesh(pd3dDevice, pd3dCommandList)
{
	// 삼각형 Mesh 정의
	m_nVertices								 = 3;
	m_nStride								 = sizeof(CDiffusedVertex);
	m_d3dPrimitiveTopology					 = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;

	/*Vertex(삼각형의 꼭지점)의 색상은 시계방향 순서대로 빨간색, 녹색, 파란색으로 지정. RGBA(Red, Green, Blue, Alpha)
	4개의 파라미터를 사용하여 색상 표현. 각 파라미터는 0.0~1.0 사이의 실수값을 가진다.*/
	CDiffusedVertex pVertices[3];
	pVertices[0] = CDiffusedVertex(XMFLOAT3(0.0f, 0.5f, 0.0f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f));
	pVertices[1] = CDiffusedVertex(XMFLOAT3(0.5f, -0.5f, 0.0f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f));
	pVertices[2] = CDiffusedVertex(XMFLOAT3(-0.5f, -0.5f, 0.0f), XMFLOAT4(Colors::Blue));

	// 삼각형 Mesh 리소스(Vertex 버퍼)로 생성
	m_pd3dVertexBuffer = ::CreateBufferResource(pd3dDevice, pd3dCommandList, pVertices, m_nStride * m_nVertices, D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, &m_pd3dVertexUploadBuffer);

	// Vertex 버퍼 뷰 생성
	m_d3dVertexBufferView.BufferLocation	 = m_pd3dVertexBuffer->GetGPUVirtualAddress();
	m_d3dVertexBufferView.StrideInBytes		 = m_nStride;
	m_d3dVertexBufferView.SizeInBytes		 = m_nStride * m_nVertices;
}

//========================================================================================================================================

CCubeMeshDiffused::CCubeMeshDiffused(ID3D12Device* pd3dDevice, ID3D12GraphicsCommandList* pd3dCommandList, FLOAT fWidth, FLOAT fHeight, FLOAT fDepth)
{
	// 직육면체는 꼭지점(Vertex)이 8개
	m_nVertices				 = 8;
	m_nStride				 = sizeof(CDiffusedVertex);
	m_d3dPrimitiveTopology	 = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;

	FLOAT fx{ fWidth * 0.5f };	 	// fWidth: 직육면체 가로(x축) 길이
	FLOAT fy{ fHeight * 0.5f };		// fHeight: 직육면체 세로(y축) 길이
	FLOAT fz{ fDepth * 0.5f };		// fDepth: 직육면체 깊이(z축) 길이

	// Vertex 버퍼는 직육면체의 꼭지점 8개에 대한 Vertex 데이터를 가진다.
	CDiffusedVertex pVertices[8];
	pVertices[0] = CDiffusedVertex(XMFLOAT3(-fx, +fy, -fz), RANDOM_COLOR);
	pVertices[1] = CDiffusedVertex(XMFLOAT3(+fx, +fy, -fz), RANDOM_COLOR);
	pVertices[2] = CDiffusedVertex(XMFLOAT3(+fx, +fy, +fz), RANDOM_COLOR);
	pVertices[3] = CDiffusedVertex(XMFLOAT3(-fx, +fy, +fz), RANDOM_COLOR);
	pVertices[4] = CDiffusedVertex(XMFLOAT3(-fx, -fy, -fz), RANDOM_COLOR);
	pVertices[5] = CDiffusedVertex(XMFLOAT3(+fx, -fy, -fz), RANDOM_COLOR);
	pVertices[6] = CDiffusedVertex(XMFLOAT3(+fx, -fy, +fz), RANDOM_COLOR);
	pVertices[7] = CDiffusedVertex(XMFLOAT3(-fx, -fy, +fz), RANDOM_COLOR);

	m_pd3dVertexBuffer = ::CreateBufferResource(pd3dDevice, pd3dCommandList, pVertices, m_nStride * m_nVertices, D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, &m_pd3dVertexUploadBuffer);
	
	// Vertex 버퍼 뷰를 생성한다.
	m_d3dVertexBufferView.BufferLocation	 = m_pd3dVertexBuffer->GetGPUVirtualAddress();
	m_d3dVertexBufferView.StrideInBytes		 = m_nStride;
	m_d3dVertexBufferView.SizeInBytes		 = m_nStride * m_nVertices;

	// Index 버퍼는 직육면체의 6개의 면(사각형)에 대한 기하 정보를 갖는다. 삼각형 리스트로 직육면체를 표현할 것이므로
	// 각 면은 2개의 삼각형을 가지고 각 삼각형은 3개의 Vertex가 필요. 즉, Index 버퍼는 전체 36(=6*2*3)개의 Index를 가져야 한다
	m_nIndices = 36;

	UINT pnIndices[36];
	
	// 앞면(Front) 사각형의 위쪽 삼각형
	pnIndices[0] = 3;
	pnIndices[1] = 1;
	pnIndices[2] = 0;
	
	// 앞면(Front) 사각형의 아래쪽 삼각형
	pnIndices[3] = 2;
	pnIndices[4] = 1;
	pnIndices[5] = 3;
	
	// 윗면(Top) 사각형의 위쪽 삼각형
	pnIndices[6] = 0;
	pnIndices[7] = 5;
	pnIndices[8] = 4;
	
	// 윗면(Top) 사각형의 아래쪽 삼각형
	pnIndices[9] = 1;
	pnIndices[10] = 5;
	pnIndices[11] = 0;
	
	// 뒷면(Back) 사각형의 위쪽 삼각형
	pnIndices[12] = 3;
	pnIndices[13] = 4;
	pnIndices[14] = 7;
	
	// 뒷면(Back) 사각형의 아래쪽 삼각형
	pnIndices[15] = 0;
	pnIndices[16] = 4;
	pnIndices[17] = 3;
	
	// 아래면(Bottom) 사각형의 위쪽 삼각형
	pnIndices[18] = 1;
	pnIndices[19] = 6;
	pnIndices[20] = 5;
	
	// 아래면(Bottom) 사각형의 아래쪽 삼각형
	pnIndices[21] = 2;
	pnIndices[22] = 6;
	pnIndices[23] = 1;
	
	// 옆면(Left) 사각형의 위쪽 삼각형
	pnIndices[24] = 2;
	pnIndices[25] = 7;
	pnIndices[26] = 6;
	
	// 옆면(Left) 사각형의 아래쪽 삼각형
	pnIndices[27] = 3;
	pnIndices[28] = 7;
	pnIndices[29] = 2;
	
	// 옆면(Right) 사각형의 위쪽 삼각형
	pnIndices[30] = 6;
	pnIndices[31] = 4;
	pnIndices[32] = 5;
	
	// 옆면(Right) 사각형의 아래쪽 삼각형
	pnIndices[33] = 7;
	pnIndices[34] = 4;
	pnIndices[35] = 6;
	
	// Index 버퍼 생성
	m_pd3dIndexBuffer = ::CreateBufferResource(pd3dDevice, pd3dCommandList, pnIndices, sizeof(UINT) * m_nIndices, D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_STATE_INDEX_BUFFER, &m_pd3dIndexUploadBuffer);
	
	// Index 버퍼 View 생성
	m_d3dIndexBufferView.BufferLocation		 = m_pd3dIndexBuffer->GetGPUVirtualAddress();
	m_d3dIndexBufferView.Format				 = DXGI_FORMAT_R32_UINT;
	m_d3dIndexBufferView.SizeInBytes		 = sizeof(UINT) * m_nIndices;
}

CCubeMeshDiffused::~CCubeMeshDiffused()
{
}

//========================================================================================================================================

CAirplaneMeshDiffused::CAirplaneMeshDiffused(ID3D12Device* pd3dDevice, ID3D12GraphicsCommandList* pd3dCommandList, FLOAT fWidth, FLOAT fHeight, FLOAT fDepth, XMFLOAT4 xmf4Color) : CMesh(pd3dDevice, pd3dCommandList)
{
	m_nVertices				 = 24 * 3;
	m_nStride				 = sizeof(CDiffusedVertex);
	m_nOffset				 = 0;
	m_nSlot					 = 0;
	m_d3dPrimitiveTopology	 = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	
	FLOAT fx{ fWidth * 0.5f };
	FLOAT fy{ fHeight * 0.5f };
	FLOAT fz{ fDepth * 0.5f };

	//위의 그림과 같은 비행기 메쉬를 표현하기 위한 Vertex 데이터이다.
	CDiffusedVertex	 pVertices[24 * 3];
	FLOAT			 x1{ fx * 0.2f };
	FLOAT			 y1{ fy * 0.2f };
	FLOAT			 x2{ fx * 0.1f };
	FLOAT			 y3{ fy * 0.3f };
	FLOAT			 y2{ ((y1 - (fy - y3)) / x1) * x2 + (fy - y3) };
	INT				 i{ 0 };

	//비행기 메쉬의 위쪽 면
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));

	//비행기 메쉬의 아래쪽 면
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	
	//비행기 메쉬의 오른쪽 면
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	
	//비행기 메쉬의 뒤쪽/오른쪽 면
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(+x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	
	//비행기 메쉬의 왼쪽 면
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, +(fy + y3), +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x2, +y2, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	
	//비행기 메쉬의 뒤쪽/왼쪽 면
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(0.0f, 0.0f, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-x1, -y1, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, +fz), Vector4::Add(xmf4Color, RANDOM_COLOR));
	pVertices[i++] = CDiffusedVertex(XMFLOAT3(-fx, -y3, -fz), Vector4::Add(xmf4Color, RANDOM_COLOR));

	m_pd3dVertexBuffer = ::CreateBufferResource(pd3dDevice, pd3dCommandList, pVertices, m_nStride * m_nVertices, D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, &m_pd3dVertexUploadBuffer);
	m_d3dVertexBufferView.BufferLocation	 = m_pd3dVertexBuffer->GetGPUVirtualAddress();
	m_d3dVertexBufferView.StrideInBytes		 = m_nStride;
	m_d3dVertexBufferView.SizeInBytes		 = m_nStride * m_nVertices;
}

CAirplaneMeshDiffused::~CAirplaneMeshDiffused()
{
}

//========================================================================================================================================

CHeightMapGridMesh::CHeightMapGridMesh(ID3D12Device* pd3dDevice, ID3D12GraphicsCommandList* pd3dCommandList, INT xStart, INT zStart, INT nWidth, INT nLength, XMFLOAT3 xmf3Scale, XMFLOAT4 xmf4Color, void* pContext)
{
	// 격자의 교점(Vertex)의 개수는 (nWidth * nLength)
	m_nVertices				 = nWidth * nLength;
	m_nStride				 = sizeof(CDiffusedVertex);

	// 격자는 삼각형 스트립으로 구성
	m_d3dPrimitiveTopology	 = D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
	m_nWidth				 = nWidth;
	m_nLength				 = nLength;
	m_xmf3Scale				 = xmf3Scale;

	CDiffusedVertex* pVertices{ new CDiffusedVertex[m_nVertices] };

	/*xStart와 zStart는 격자의 시작 위치(x좌표와 z좌표)를 나타낸다. 커다란 지형은 격자들의 이차원 배열로 만들
	필요가 있기 때문에 전체 지형에서 각 격자의 시작 위치를 나타내는 정보가 필요하다.*/
	FLOAT fHeight{ 0.0f };
	FLOAT fMinHeight{ +FLT_MAX };
	FLOAT fMaxHeight{ -FLT_MAX };

	for (INT i = 0, z = zStart; z < (zStart + nLength); ++z)
	{
		for (INT x = xStart; x < (xStart + nWidth); ++x, ++i)
		{
			//Vertex의 높이와 색상을 Height Map으로부터 구한다.
			XMFLOAT3 xmf3Position{ XMFLOAT3((x * m_xmf3Scale.x), OnGetHeight(x, z, pContext), (z * m_xmf3Scale.z)) };
			XMFLOAT4 xmf3Color{ Vector4::Add(OnGetColor(x, z, pContext), xmf4Color) };

			pVertices[i] = CDiffusedVertex(xmf3Position, xmf3Color);

			if (fHeight < fMinHeight)
				fMinHeight = fHeight;

			if (fHeight > fMaxHeight)
				fMaxHeight = fHeight;
		}
	}

	m_pd3dVertexBuffer = ::CreateBufferResource(pd3dDevice, pd3dCommandList, pVertices, m_nStride * m_nVertices, D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, &m_pd3dVertexUploadBuffer);

	m_d3dVertexBufferView.BufferLocation	 = m_pd3dVertexBuffer->GetGPUVirtualAddress();
	m_d3dVertexBufferView.StrideInBytes		 = m_nStride;
	m_d3dVertexBufferView.SizeInBytes		 = m_nStride * m_nVertices;

	delete[] pVertices;

	/*격자는 사각형들의 집합이고 사각형은 두 개의 삼각형으로 구성되므로 격자는 다음 그림과 같이 삼각형들의 집합이라고 할 수 있다.
	격자를 표현하기 위하여 격자의 삼각형들을 Vertex 버퍼의 Index로 표현해야 한다.
	삼각형 스트립을 사용하여 삼각형들을 표현하기 위하여 삼각형들은 사각형의 줄 단위로 아래에서 위쪽 방향으로(z축) 나열한다.
	첫 번째 사각형 줄의 삼각형들은 왼쪽에서 오른쪽으로(x축) 나열한다.
	두 번째 줄의 삼각형들은 오른쪽에서 왼쪽 방향으로 나열한다.
	즉, 사각형의 줄이 바뀔 때마다 나열 순서가 바뀌도록 한다.
	다음 그림의 격자에 대하여 삼각형 스트립을 사용하여 삼각형들을 표현하기 위한 Index의 나열은 다음과 같이 격자의 m번째 줄과
	(m + 1)번째 줄의	Vertex 번호를 사각형의 나열 방향에 따라 번갈아 아래, 위, 아래, 위, ... 순서로 나열하면 된다.
		0, 6, 1, 7, 2, 8, 3, 9, 4, 10, 5, 11, 11, 17, 10, 16, 9, 15, 8, 14, 7, 13, 6, 12
	이렇게 Index를 나열하면 삼각형 스트립을 사용할 것이므로 실제 그려지는 삼각형들의 Index는 다음과 같다.
		(0, 6, 1), (1, 6, 7), (1, 7, 2), (2, 7, 8), (2, 8, 3), (3, 8, 9), ...
	그러나 이러한 Index를 사용하면 첫 번째 줄을 제외하고 삼각형들이 제대로 그려지지 않는다.
	왜냐하면 삼각형 스트립에서는 마지막 2개의 Vertex과 새로운 하나의 Vertex을 사용하여 새로운 삼각형을 그린다.
	그리고 홀수 번째 삼각형의 Vertex 나열 순서(와인딩 순서)는 시계방향이고 짝수 번째 삼각형의 와인딩 순서는 반시계 방향이어야 한다.
	격자의 사각형이 한 줄에서 몇 개가 있던지 상관없이 한 줄의 마지막 삼각형은 짝수 번째 삼각형이고 와인딩 순서는 반시계 방향이다.
	왜냐하면 사각형은 두 개의 삼각형으로 나누어지기 때문이다.
	첫 번째 줄에서 두 번째 줄의 Index 나열과 실제 그려지는 삼각형들의 Index를 살펴보자.
		..., 4, 10, 5, 11, 11, 17, 10, 16, 9, 15, 8, 14, 7, 13, 6, 12, ...
		..., (4, 10, 5), (5, 10, 11), (5, 11, 11), (11, 11, 17), (11, 17, 10), ...
	삼각형 (5, 10, 11)은 첫 번째 줄의 마지막 삼각형이고 짝수 번째이다.
	삼각형 (11, 17, 10)은 두 번째 줄의 첫 번째 삼각형이고 홀수 번째이다.
	홀수 번째이므로 와인딩 순서가 시계방향이어야 하는데 실제 와인딩 순서는 반시계 방향이므로 그려지지 않을 것이다.
	당연히 다음 삼각형도 와인딩 순서가 맞지 않으므로 그려지지 않을 것이다.
	삼각형 (11, 17, 10)의 와인딩 순서가 반시계방향이므로 그려지도록 하려면 이 삼각형이 짝수 번째 삼각형이 되도록 해야 한다.
	이를 위해서 줄이 바뀔 때마다 마지막 Vertex의 Index를 추가하도록 하자.
	그러면 줄이 바뀐 첫 번째 삼각형은 짝수 번째 삼각형이 된다.
	다음의 예에서는 11이 추가된 마지막 Vertex의 Index이다.
	이렇게 하면 삼각형을 구성할 수 없어서 그려지지 않는 삼각형이 각 줄마다 3개씩 생기게 된다.
		..., 4, 10, 5, 11, 11, 11, 17, 10, 16, 9, 15, 8, 14, 7, 13, 6, 12, ...
		..., (5, 10, 11), (5, 11, 11), (11, 11, 11), (11, 11, 17), (11, 17, 10), ...
	세 개의 삼각형 (5, 11, 11), (11, 11, 11), (11, 11, 17)은 삼각형을 구성할 수 없으므로 실제로 그려지지 않는다.
	이렇게 Index를 나열하면 Index 버퍼는 ((nWidth * 2) * (nLength - 1)) + ((nLength - 1) - 1)개의 Index를 갖는다.
	사각형 줄의 개수는 (nLength - 1)이고 한 줄에서 (nWidth * 2)개의 Index를 갖는다.
	그리고 줄이 바뀔 때마다 Index를 하나 추가하므로 (nLength - 1) - 1개의 Index가 추가로 필요하다.*/

	m_nIndices = ((nWidth * 2) * (nLength - 1)) + ((nLength - 1) - 1);

	UINT* pnIndices{ new UINT[m_nIndices] };

	for (INT j = 0, z = 0; z < nLength - 1; ++z)
	{
		if ((z % 2) == 0)
		{
			// 홀수 번째 줄이므로(z = 0, 2, 4, ...) Index의 나열 순서는 왼쪽에서 오른쪽 방향
			for (INT x = 0; x < nWidth; ++x)
			{
				// 첫 번째 줄을 제외하고 줄이 바뀔 때마다(x == 0) 첫 번째 Index 추가
				if ((x == 0) && (z > 0))
					pnIndices[j++] = (UINT)(x + (z * nWidth));

				// 아래(x, z), 위(x, z + 1)의 순서로 Index 추가
				pnIndices[j++] = (UINT)(x + (z * nWidth));
				pnIndices[j++] = (UINT)((x + (z * nWidth)) + nWidth);
			}
		}
		else
		{
			// 짝수 번째 줄이므로(z = 1, 3, 5, ...) Index의 나열 순서는 오른쪽에서 왼쪽 방향
			for (INT x = nWidth - 1; x >= 0; --x)
			{
				// 줄이 바뀔 때마다(x == (nWidth - 1)) 첫 번째 Index 추가
				if (x == (nWidth - 1))
					pnIndices[j++] = (UINT)(x + (z * nWidth));

				// 아래(x, z), 위(x, z + 1)의 순서로 Index 추가
				pnIndices[j++] = (UINT)(x + (z * nWidth));
				pnIndices[j++] = (UINT)((x + (z * nWidth)) + nWidth);
			}
		}
	}

	m_pd3dIndexBuffer = ::CreateBufferResource(pd3dDevice, pd3dCommandList, pnIndices, sizeof(UINT) * m_nIndices, D3D12_HEAP_TYPE_DEFAULT, D3D12_RESOURCE_STATE_INDEX_BUFFER, &m_pd3dIndexUploadBuffer);
	
	m_d3dIndexBufferView.BufferLocation	 = m_pd3dIndexBuffer->GetGPUVirtualAddress();
	m_d3dIndexBufferView.Format			 = DXGI_FORMAT_R32_UINT;
	m_d3dIndexBufferView.SizeInBytes	 = sizeof(UINT) * m_nIndices;

	delete[] pnIndices;
}

CHeightMapGridMesh::~CHeightMapGridMesh()
{
}

// Height Map 이미지의 Pixel 값을 지형의 높이로 반환
FLOAT CHeightMapGridMesh::OnGetHeight(INT x, INT z, void* pContext)
{
	CHeightMapImage*	 pHeightMapImage{ (CHeightMapImage*)pContext };
	BYTE*				 pHeightMapPixels{ pHeightMapImage->GetHeightMapPixels() };
	XMFLOAT3			 xmf3Scale{ pHeightMapImage->GetScale() };
	INT					 nWidth{ pHeightMapImage->GetHeightMapWidth() };
	FLOAT				 fHeight{ pHeightMapPixels[x + (z * nWidth)] * xmf3Scale.y };

	return fHeight;
}

XMFLOAT4 CHeightMapGridMesh::OnGetColor(INT x, INT z, void* pContext)
{
	// 조명의 방향 벡터(Vertex에서 조명까지의 벡터)
	XMFLOAT3			 xmf3LightDirection{ XMFLOAT3(-1.0f, 1.0f, 1.0f) };
	xmf3LightDirection = Vector3::Normalize(xmf3LightDirection);

	CHeightMapImage*	 pHeightMapImage{ (CHeightMapImage*)pContext };
	XMFLOAT3			 xmf3Scale{ pHeightMapImage->GetScale() };

	// 조명의 색상(세기, 밝기)
	XMFLOAT4			 xmf4IncidentLightColor(0.9f, 0.8f, 0.4f, 1.0f);
	/*Vertex (x, z)에서 조명이 반사되는 양(비율)은 Vertex (x, z)의 법선 벡터와 조명의 방향 벡터의 내적(cos)과 인접한
	3개의 Vertex (x+1, z), (x, z+1), (x+1, z+1)의 법선 벡터와 조명의 방향 벡터의 내적을 평균하여 구한다.
	Vertex (x, z)의 색상은 조명 색상(세기)과 반사되는 양(비율)을 곱한 값이다.*/
	FLOAT fScale{ Vector3::DotProduct(pHeightMapImage->GetHeightMapNormal(x, z), xmf3LightDirection) };

	fScale += Vector3::DotProduct(pHeightMapImage->GetHeightMapNormal(x + 1, z), xmf3LightDirection);
	fScale += Vector3::DotProduct(pHeightMapImage->GetHeightMapNormal(x + 1, z + 1), xmf3LightDirection);
	fScale += Vector3::DotProduct(pHeightMapImage->GetHeightMapNormal(x, z + 1), xmf3LightDirection);
	fScale = (fScale / 4.0f) + 0.05f;

	if (fScale > 1.0f)
		fScale = 1.0f;

	if (fScale < 0.25f)
		fScale = 0.25f;

	// fScale은 조명 색상(밝기)이 반사되는 비율
	XMFLOAT4 xmf4Color{ Vector4::Multiply(fScale, xmf4IncidentLightColor) };

	return xmf4Color;
}
